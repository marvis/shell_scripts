echo "create lesson6.c ..."
if [ "1" ] ; then 
echo '//'
echo '//'
echo '// This code was created by Jeff Molofee '"'"'99 (ported to Linux/GLUT by Richard Campbell '"'"'99)'
echo '//'
echo '// If you'"'"'ve found this code useful, please let me know.'
echo '//'
echo '// Visit me at www.demonews.com/hosted/nehe '
echo '// (email Richard Campbell at ulmont@bellsouth.net)'
echo '//'
echo '#include <GL/glut.h>    // Header File For The GLUT Library '
echo '#include <GL/gl.h>	// Header File For The OpenGL32 Library'
echo '#include <GL/glu.h>	// Header File For The GLu32 Library'
echo '#include <stdio.h>      // Header file for standard file i/o.'
echo '#include <stdlib.h>     // Header file for malloc/free.'
echo '#include <unistd.h>     // needed to sleep.'
echo ''
echo '/* ascii code for the escape key */'
echo '#define ESCAPE 27'
echo ''
echo '/* The number of our GLUT window */'
echo 'int window; '
echo ''
echo '/* floats for x rotation, y rotation, z rotation */'
echo 'float xrot, yrot, zrot;'
echo ''
echo '/* storage for one texture  */'
echo 'int texture[1];'
echo ''
echo '/* Image type - contains height, width, and data */'
echo 'struct Image {'
echo '    unsigned long sizeX;'
echo '    unsigned long sizeY;'
echo '    char *data;'
echo '};'
echo 'typedef struct Image Image;'
echo ''
echo '// quick and dirty bitmap loader...for 24 bit bitmaps with 1 plane only.  '
echo '// See http://www.dcs.ed.ac.uk/~mxr/gfx/2d/BMP.txt for more info.'
echo 'int ImageLoad(char *filename, Image *image) {'
echo '    FILE *file;'
echo '    unsigned long size;                 // size of the image in bytes.'
echo '    unsigned long i;                    // standard counter.'
echo '    unsigned short int planes;          // number of planes in image (must be 1) '
echo '    unsigned short int bpp;             // number of bits per pixel (must be 24)'
echo '    char temp;                          // temporary color storage for bgr-rgb conversion.'
echo ''
echo '    // make sure the file is there.'
echo '    if ((file = fopen(filename, "rb"))==NULL)'
echo '    {'
echo '	printf("File Not Found : %s\n",filename);'
echo '	return 0;'
echo '    }'
echo '    '
echo '    // seek through the bmp header, up to the width/height:'
echo '    fseek(file, 18, SEEK_CUR);'
echo ''
echo '    // read the width'
echo '    if ((i = fread(&image->sizeX, 4, 1, file)) != 1) {'
echo '	printf("Error reading width from %s.\n", filename);'
echo '	return 0;'
echo '    }'
echo '    printf("Width of %s: %lu\n", filename, image->sizeX);'
echo '    '
echo '    // read the height '
echo '    if ((i = fread(&image->sizeY, 4, 1, file)) != 1) {'
echo '	printf("Error reading height from %s.\n", filename);'
echo '	return 0;'
echo '    }'
echo '    printf("Height of %s: %lu\n", filename, image->sizeY);'
echo '    '
echo '    // calculate the size (assuming 24 bits or 3 bytes per pixel).'
echo '    size = image->sizeX * image->sizeY * 3;'
echo ''
echo '    // read the planes'
echo '    if ((fread(&planes, 2, 1, file)) != 1) {'
echo '	printf("Error reading planes from %s.\n", filename);'
echo '	return 0;'
echo '    }'
echo '    if (planes != 1) {'
echo '	printf("Planes from %s is not 1: %u\n", filename, planes);'
echo '	return 0;'
echo '    }'
echo ''
echo '    // read the bpp'
echo '    if ((i = fread(&bpp, 2, 1, file)) != 1) {'
echo '	printf("Error reading bpp from %s.\n", filename);'
echo '	return 0;'
echo '    }'
echo '    if (bpp != 24) {'
echo '	printf("Bpp from %s is not 24: %u\n", filename, bpp);'
echo '	return 0;'
echo '    }'
echo '	'
echo '    // seek past the rest of the bitmap header.'
echo '    fseek(file, 24, SEEK_CUR);'
echo ''
echo '    // read the data. '
echo '    image->data = (char *) malloc(size);'
echo '    if (image->data == NULL) {'
echo '	printf("Error allocating memory for color-corrected image data");'
echo '	return 0;	'
echo '    }'
echo ''
echo '    if ((i = fread(image->data, size, 1, file)) != 1) {'
echo '	printf("Error reading image data from %s.\n", filename);'
echo '	return 0;'
echo '    }'
echo ''
echo '    for (i=0;i<size;i+=3) { // reverse all of the colors. (bgr -> rgb)'
echo '	temp = image->data[i];'
echo '	image->data[i] = image->data[i+2];'
echo '	image->data[i+2] = temp;'
echo '    }'
echo '    '
echo '    // we'"'"'re done.'
echo '    return 1;'
echo '}'
echo '    '
echo '// Load Bitmaps And Convert To Textures'
echo 'void LoadGLTextures() {	'
echo '    // Load Texture'
echo '    Image *image1;'
echo '    '
echo '    // allocate space for texture'
echo '    image1 = (Image *) malloc(sizeof(Image));'
echo '    if (image1 == NULL) {'
echo '	printf("Error allocating space for image");'
echo '	exit(0);'
echo '    }'
echo ''
echo '    if (!ImageLoad("Data/lesson6/NeHe.bmp", image1)) {'
echo '	exit(1);'
echo '    }        '
echo ''
echo '    // Create Texture	'
echo '    glGenTextures(1, &texture[0]);'
echo '    glBindTexture(GL_TEXTURE_2D, texture[0]);   // 2d texture (x and y size)'
echo ''
echo '    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); // scale linearly when image bigger than texture'
echo '    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); // scale linearly when image smalled than texture'
echo ''
echo '    // 2d texture, level of detail 0 (normal), 3 components (red, green, blue), x size from image, y size from image, '
echo '    // border 0 (normal), rgb color data, unsigned byte data, and finally the data itself.'
echo '    glTexImage2D(GL_TEXTURE_2D, 0, 3, image1->sizeX, image1->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, image1->data);'
echo '};'
echo ''
echo '/* A general OpenGL initialization function.  Sets all of the initial parameters. */'
echo 'void InitGL(int Width, int Height)	        // We call this right after our OpenGL window is created.'
echo '{'
echo '    LoadGLTextures();				// Load The Texture(s) '
echo '    glEnable(GL_TEXTURE_2D);			// Enable Texture Mapping'
echo '    glClearColor(0.0f, 0.0f, 1.0f, 0.0f);	// Clear The Background Color To Blue '
echo '    glClearDepth(1.0);				// Enables Clearing Of The Depth Buffer'
echo '    glDepthFunc(GL_LESS);			// The Type Of Depth Test To Do'
echo '    glEnable(GL_DEPTH_TEST);			// Enables Depth Testing'
echo '    glShadeModel(GL_SMOOTH);			// Enables Smooth Color Shading'
echo '    '
echo '    glMatrixMode(GL_PROJECTION);'
echo '    glLoadIdentity();				// Reset The Projection Matrix'
echo '    '
echo '    gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);	// Calculate The Aspect Ratio Of The Window'
echo '    '
echo '    glMatrixMode(GL_MODELVIEW);'
echo '}'
echo ''
echo '/* The function called when our window is resized (which shouldn'"'"'t happen, because we'"'"'re fullscreen) */'
echo 'void ReSizeGLScene(int Width, int Height)'
echo '{'
echo '    if (Height==0)				// Prevent A Divide By Zero If The Window Is Too Small'
echo '	Height=1;'
echo ''
echo '    glViewport(0, 0, Width, Height);		// Reset The Current Viewport And Perspective Transformation'
echo ''
echo '    glMatrixMode(GL_PROJECTION);'
echo '    glLoadIdentity();'
echo ''
echo '    gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);'
echo '    glMatrixMode(GL_MODELVIEW);'
echo '}'
echo ''
echo '/* The main drawing function. */'
echo 'void DrawGLScene()'
echo '{'
echo '    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);		// Clear The Screen And The Depth Buffer'
echo '    glLoadIdentity();				// Reset The View'
echo ''
echo '    glTranslatef(0.0f,0.0f,-5.0f);              // move 5 units into the screen.'
echo '    '
echo '    glRotatef(xrot,1.0f,0.0f,0.0f);		// Rotate On The X Axis'
echo '    glRotatef(yrot,0.0f,1.0f,0.0f);		// Rotate On The Y Axis'
echo '    glRotatef(zrot,0.0f,0.0f,1.0f);		// Rotate On The Z Axis'
echo ''
echo '    glBindTexture(GL_TEXTURE_2D, texture[0]);   // choose the texture to use.'
echo ''
echo '    glBegin(GL_QUADS);		                // begin drawing a cube'
echo '    '
echo '    // Front Face (note that the texture'"'"'s corners have to match the quad'"'"'s corners)'
echo '    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);	// Bottom Left Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);	// Bottom Right Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f,  1.0f);	// Top Right Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f,  1.0f);	// Top Left Of The Texture and Quad'
echo '    '
echo '    // Back Face'
echo '    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);	// Bottom Right Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);	// Top Right Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);	// Top Left Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f);	// Bottom Left Of The Texture and Quad'
echo '	'
echo '    // Top Face'
echo '    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);	// Top Left Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,  1.0f,  1.0f);	// Bottom Left Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f,  1.0f,  1.0f);	// Bottom Right Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);	// Top Right Of The Texture and Quad'
echo '    '
echo '    // Bottom Face       '
echo '    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f);	// Top Right Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f);	// Top Left Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);	// Bottom Left Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);	// Bottom Right Of The Texture and Quad'
echo '    '
echo '    // Right face'
echo '    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f);	// Bottom Right Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);	// Top Right Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f,  1.0f,  1.0f);	// Top Left Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);	// Bottom Left Of The Texture and Quad'
echo '    '
echo '    // Left Face'
echo '    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);	// Bottom Left Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);	// Bottom Right Of The Texture and Quad'
echo '    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f,  1.0f,  1.0f);	// Top Right Of The Texture and Quad'
echo '    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);	// Top Left Of The Texture and Quad'
echo '    '
echo '    glEnd();                                    // done with the polygon.'
echo ''
echo '    //xrot+=15.0f;		                // X Axis Rotation	'
echo '    //yrot+=15.0f;		                // Y Axis Rotation'
echo '    //zrot+=15.0f;		                // Z Axis Rotation'
echo '    xrot+=1.0f;		                // X Axis Rotation	'
echo '    yrot+=1.0f;		                // Y Axis Rotation'
echo ''
echo '    // since this is double buffered, swap the buffers to display what just got drawn.'
echo '    glutSwapBuffers();'
echo '}'
echo ''
echo '/* The function called whenever a key is pressed. */'
echo 'void keyPressed(unsigned char key, int x, int y) '
echo '{'
echo '    /* avoid thrashing this procedure */'
echo '    usleep(100);'
echo ''
echo '    /* If escape is pressed, kill everything. */'
echo '    if (key == ESCAPE) '
echo '    { '
echo '	/* shut down our window */'
echo '	glutDestroyWindow(window); '
echo '      '
echo '      /* exit the program...normal termination. */'
echo '	exit(0);                   '
echo '    }'
echo '}'
echo ''
echo 'int main(int argc, char **argv) '
echo '{  '
echo '    /* Initialize GLUT state - glut will take any command line arguments that pertain to it or '
echo '       X Windows - look at its documentation at http://reality.sgi.com/mjk/spec3/spec3.html */  '
echo '    glutInit(&argc, argv);  '
echo ''
echo '    /* Select type of Display mode:   '
echo '     Double buffer '
echo '     RGBA color'
echo '     Alpha components supported '
echo '     Depth buffer */  '
echo '    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);  '
echo ''
echo '    /* get a 640 x 480 window */'
echo '    glutInitWindowSize(640, 480);  '
echo ''
echo '    /* the window starts at the upper left corner of the screen */'
echo '    glutInitWindowPosition(0, 0);  '
echo ''
echo '    /* Open a window */  '
echo '    window = glutCreateWindow("Jeff Molofee'"'"'s GL Code Tutorial ... NeHe '"'"'99");  '
echo ''
echo '    /* Register the function to do all our OpenGL drawing. */'
echo '    glutDisplayFunc(&DrawGLScene);  '
echo ''
echo '    /* Go fullscreen.  This is as soon as possible. */'
echo '    glutFullScreen();'
echo ''
echo '    /* Even if there are no events, redraw our gl scene. */'
echo '    glutIdleFunc(&DrawGLScene);'
echo ''
echo '    /* Register the function called when our window is resized. */'
echo '    glutReshapeFunc(&ReSizeGLScene);'
echo ''
echo '    /* Register the function called when the keyboard is pressed. */'
echo '    glutKeyboardFunc(&keyPressed);'
echo ''
echo '    /* Initialize our window. */'
echo '    InitGL(640, 480);'
echo '  '
echo '    /* Start Event Processing Engine */  '
echo '    glutMainLoop();  '
echo ''
echo '    return 1;'
echo '}'
echo ''
fi > lesson6.c

echo "create makefile ..."
if [ "1" ] ; then 
echo 'INCLUDE = -I/usr/include/'
echo 'LIBDIR  = -L/usr/X11R6/lib '
echo ''
echo 'COMPILERFLAGS = -Wall'
echo 'CC = gcc'
echo 'CFLAGS = $(COMPILERFLAGS) $(INCLUDE)'
echo 'LIBRARIES = -lX11 -lXi -lXmu -lglut -lGL -lGLU -lm '
echo ''
echo '# for all, set the targets to be every lesson1.c-lesson13.c '
echo '# file, removing the .c extension.  That is, at this point,'
echo '# it would produce lesson1, lesson2, lesson3,...,lesson13 targets.'
echo '#'
echo 'all: $(basename $(wildcard lesson[1-9].c lesson1[0-3].c))'
echo ''
echo '# same as for all, except set the targets to be '
echo '# lessonX.tar.gz from lessonX.c.  This is really'
echo '# only used to build smaller tutorial .tar.gz files'
echo '# to send to nehe.'
echo '#'
echo 'dist: $(foreach file,$(basename $(wildcard lesson[1-9].c lesson1[0-3].c)),$(file).tar.gz)'
echo ''
echo '# to produce, say, lesson1.tar.gz:'
echo '#'
echo '# 1. remove lesson1.tar.gz'
echo '# 2. build lesson1.tar containing README, makefile, lesson1.c, Data/lesson1/*.'
echo '# 3. gzip lesson1.tar.'
echo '#'
echo 'lesson%.tar.gz : '
echo '	tar cvf $(subst .tar.gz,.tar,$@) README makefile $(subst .tar.gz,.c,$@) $(wildcard Data/$(subst .tar.gz,,$@)/*); \'
echo '	gzip $(subst .tar.gz,.tar,$@);'
echo ''
echo '# to produce, say, lesson1:'
echo '#'
echo '# 1. compile the thing.  uses the variables defined above.'
echo '# '
echo 'lesson% : lesson%.o'
echo '	$(CC) $(CFLAGS) -o $@ $(LIBDIR) $< $(LIBRARIES)  '
echo ''
echo '# to clean up:'
echo '# delete all of the lessonX files.'
echo 'clean:'
echo '	rm $(wildcard lesson[1-9] lesson1[0-3])'
echo ''
echo '# to clean up the distributions:'
echo '# delete all of the lessonX.tar.gz files.'
echo 'distclean:'
echo '	rm $(wildcard lesson[1-9].tar.gz lesson1[0-3].tar.gz)'
echo ''
fi > makefile

